

import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm, datasets
from sklearn.metrics import roc_curve, auc
from sklearn.cross_validation import train_test_split
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier
import pandas as pd
from scipy import interpolate
from matplotlib.backends.backend_pdf import PdfPages
import csv
import subprocess, os
import sys, getopt
import datetime
import hashlib
import config
import StringIO

def md5(fname):
    hash_md5 = hashlib.md5()
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

class SensibilityInterpolator:
    """
    A sensibility interpolator that uses linear interpolation to calculate
    new sensibility values from false positive rate points.
    """

    def __init__(self, fpr, tpr, kind = 'linear'):
        self.fpr = fpr
        self.tpr = tpr

        # Creates a function to interpolates the false positive rate list as x axis
        # true positive rate list as y axis
        self.f = interpolate.interp1d(fpr, tpr, kind)

    def sensibility(self, fpr):
        return self.f(fpr)

class WekaClassifierThresholdFile:
    """Represents a threshold file generated by weka and that can be loaded
    using the constructor"""

    def __init__(self, file_location):
        data = pd.read_csv(file_location, header=0)
        self.data = data

    def false_positive_rate(self):
        """Returns a list of false positive rates columns from the CSV file"""
        return self.data.as_matrix(columns = ['\'False Positive Rate\'']).squeeze()

    def true_positive_rate(self):
        """Returns a list of true positive rates columns from the CSV file"""
        return self.data.as_matrix(columns = ['\'True Positive Rate\'']).squeeze()

    def aroc(self):
        """Return the calculated area under ROC from fpr and tpr columns"""
        return auc(self.false_positive_rate(), self.true_positive_rate())

    def sensibility_interpolator(self):
        return SensibilityInterpolator(self.false_positive_rate(), self.true_positive_rate())


class WekaClassifierExecution:
    """
    Represents a classifier trainning and testing execution.

    Keyword arguments:
    classifier_name -- Name of the classifier algorithm that was used to train the classifier
    threshold_file -- A WekaClassifierThresholdFile instance with classifier threshold information
    command -- Command line used to call Weka
    """
    def __init__(self, classifier_name, threshold_file, command):
        self.classifier_name = classifier_name
        self.threshold_file = threshold_file
        self.command = command

class WekaClassifierFullExecution:
    """
    A simple wrapper that keep the train execution and test execution
    """
    def __init__(self, train, test):
        self.train = train
        self.test = test

class WekaClassifiersSummaryCSVWriter:
    """Summarizes the results from each classifier into a CSV file."""

    def __init__(self, specificity_points):

        # Inverse the specificity points to false positive rate points,
        # i.e: from 0.9 to 0.1
        self.fpr_points = [round(1 - x, 2) for x in specificity_points]

        # Creates a list of percentage headers for the specificities
        # i.e.: 0.9, 0.8, 0.7, 0.6 -> ('90%', '80%', '70%', '60%')
        self.spec_percentage_headers = [("%d%%" % (x * 100)) for x in specificity_points]

        # A list with all the CSV header names, appending the specificity columns in the middle
        self.headers = ["Classificador", "AROC"] + self.spec_percentage_headers + ["Train Command", "Test Command"]

        # Open a buffer to store the CSV output
        self.csvfile = StringIO.StringIO()

        # Create a CSV writer to write to the buffer
        self.csvwriter = csv.DictWriter(self.csvfile, fieldnames = self.headers)

        # Write the headers to the beginning of the file
        # i.e "Classificador", "AROC"...
        self.csvwriter.writeheader()

    def add_classifier(self, classifier_execution):
        # Create the interpolator based on threshold file
        interpolator = classifier_execution.train.threshold_file.sensibility_interpolator()

        # Calculate AROC value
        aroc = classifier_execution.train.threshold_file.aroc()

        # For each specificity point, generates a sensibility point from
        # the interpolator function
        sensibilities = [interpolator.sensibility(x) for x in self.fpr_points]

        # Scale to 3, i.e: 0.432
        sensibilities = [round(x, 3) for x in sensibilities]

        # Put all sensibilities to a dictionary, ie: {'90%': 0.678, '80%': 0.765, '70%': 0.876}
        sensibilities_values = dict(zip(self.spec_percentage_headers, sensibilities))

        # Create a dictionary that will be transformed in a row in the CSV file.
        row = {
            'Classificador': classifier_execution.train.classifier_name,
            'AROC':          '%0.3f' % aroc,
            'Train Command': classifier_execution.train.command,
            'Test Command':  classifier_execution.test.command
        }

        # Add the sensibilities dictionary to the row
        row.update(sensibilities_values)

        # Write all the row to the CSV file (in memory)
        self.csvwriter.writerow(row)

    def get_csv(self):
        """Returns the CSV generated until now"""
        return self.csvfile.getvalue()

    def write_to_file(self, file_location):
        """ Write the content of the CSV buffer to a file"""

        # Open the file
        fd = open(file_location, 'w')

        # Write the content to the file
        fd.write(self.csvfile.getvalue())

        fd.close()


class WekaROCChartBuilder:
    """Builder that creates a ROC curve chart for one or more curves"""

    def __init__(self, title):
        self.title = title
        self.executions = []
        self.titles = []

    def add_classifier(self, classifier_execution, title = None):
        # Get the threshold_file instance
        self.executions.append(classifier_execution)

        self.titles.append(title if title != None else classifier_execution.classifier_name)

    def write_to_file(self, file_location):
        plt.figure()

        for e,i in zip(self.executions, range(len(self.executions))):
            threshold = e.threshold_file
            # Plot the line from the ROC curve for this classifier
            plt.plot(
                threshold.false_positive_rate(),
                threshold.true_positive_rate(),
                label='%s (area = %0.3f)' % (self.titles[i], threshold.aroc()))

        plt.plot([0, 1], [0, 1], 'k--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title(self.title)
        plt.legend(loc="lower right", fontsize = 10)

        pp = PdfPages(file_location)

        plt.savefig(pp, format='pdf')
        pp.close()

class WekaClassifierBuilder:

    def __init__(self, experiment_dir, classifier):
        """
            Parameters:
              experiment_dir - directory where the experiment is running
              classifier - the classifier map with algorithm and parameters that will be used to train the model
        """
        self.classifier = classifier
        self.experiment_dir = experiment_dir
        self.classifier_dir = experiment_dir + "/" + self.classifier['token']

    def train_command(self, weka_lib, train_file):
        """
            Creates the command line to train a classifier model and persist
            the result in the specified directory.

            Parameters:
              weka_lib - the location where weka jar is placed
              train_file - file with dataset that will be used to train
        """
        print("Creating classifier with %s" % self.classifier['name'])

        command = "java -cp %s weka.Run %s" % (weka_lib, self.classifier['command-line'])

        # Setting trainning dataset
        command += " -t %s" % train_file

        # Setting where the classifier model should be saved
        command += " -d %s/%s.model" % (self.classifier_dir, self.classifier['token'])

        # Setting where to save the ROC curve file
        # Use the label 'G' (Glaucoma) as the reference
        command += " -threshold-file %s/train.curve.arff.csv -threshold-label G" % self.classifier_dir

        if 'meta' in self.classifier:
            command += " " + self.classifier['meta']

        return command


    def execute(self, command):
        # Execute command ad redirect output
        subprocess.check_output(command + (" | tee %s" % (self.classifier_dir + "/train.statistics.txt")), shell=True)

        # Create the execution instance to load the threshold file
        return WekaClassifierExecution(
            classifier_name = self.classifier['token'],
            threshold_file = WekaClassifierThresholdFile(file_location = self.classifier_dir + "/train.curve.arff.csv"),
            command = command)

class WekaClassifierTester:
    """
    Apply the classifier model trainned before and located
    at experiment_dir/claissifier_dir/classifier_token.model
    to each instance of the test_file.csv.
    """

    def __init__(self, experiment_dir, classifier):
        """
            Parameters:
              experiment_dir - directory where the experiment is running
              classifier - the classifier map with algorithm and parameters that will be used to train the model
        """
        self.classifier = classifier
        self.experiment_dir = experiment_dir
        self.classifier_dir = experiment_dir + "/" + self.classifier['token']

    def test_command(self, weka_lib, test_file):

        # Setting the classifier name
        command = "java -cp %s weka.Run %s" % (weka_lib, self.classifier['algorithm'])
        # Loading the model that already was trainned
        command += " -l %s/%s.model" % (self.classifier_dir, self.classifier['token'])

        # Setting testing dataset if exists
        command += " -T %s" % test_file

        # Weka has a problem that it not print the resume and the
        # classification per instance at the same time. To work around This
        # problem, method return two commands that can be used to append the execution
        # from the second one the file from the first one.
        summary_command = command

        command += " -classifications weka.classifiers.evaluation.output.prediction.PlainText"

        # Setting where to save the ROC curve file
        # Use the label 'G' (Glaucoma) as the reference
        command += " -threshold-file %s/test.curve.arff.csv -threshold-label G" % self.classifier_dir

        per_instance_command = command

        return summary_command, per_instance_command

    def execute(self, summary_command, per_instance_command):
        # Executing the command and redirect to output file
        subprocess.check_output(summary_command + (" | tee %s" % (self.classifier_dir + "/test.statistics.txt")), shell=True)

        # Executing the command and append to the same file
        subprocess.check_output(per_instance_command + (" | tee -a %s" % (self.classifier_dir + "/test.statistics.txt")), shell=True)

        # Create the execution instance to load the threshold file
        return WekaClassifierExecution(
            classifier_name = self.classifier['token'],
            threshold_file = WekaClassifierThresholdFile(file_location = self.classifier_dir + "/test.curve.arff.csv"),
            command = per_instance_command)

class WekaClassifierExecutor:

    def __init__(self, experiment_dir, weka_jar, train_file, test_file, classifiers, specificities_points, interpolation_kind, config):
        """
        Create the executor with all the parameters specified by user in command line
        experiment_dir - Directory where the classifier result files will be stored
        weka_jar - The location of the executable Weka JAR
        train_file - The location of the train dataset
        test_file - The location of the test dataset
        classifiers - A list of classifiers that will be build. ie. ['naive-byes', 'bagging']
        specificities_points - A list of points [0.0, 1.0] to discover the respective sensibilities
        interpolation_kind - The method used to interpolate the sensibilities
        config - The config object
        """

        self.config = config

        self.experiment_dir = 'experiments/' + experiment_dir
        self.experiment_date = datetime.datetime.now()

        if (not os.path.isfile(weka_jar)):
            print "Weka jar file %s not found" % weka_jar
            return

        self.weka_jar = weka_jar

        if (not os.path.isfile(train_file)):
            print "Train dataset file %s not found." % train
            return

        self.train_file = train_file
        self.train_md5 = md5(train_file) if train_file else ""

        if (not os.path.isfile(test_file)):
            print "Test dataset file %s not found" % test
            return

        self.test_file = test_file
        self.test_md5 = md5(test_file) if test_file else ""

        all_classifiers = []
        if not classifiers:
          all_classifiers = config.classifiers
        else:
          all_classifiers = [c for c in config.classifiers if c['token'] in classifiers]

        self.classifiers = all_classifiers

        self.specificities_points = specificities_points
        self.interpolation_kind = interpolation_kind

    def run(self):
        """
        Start to train classifiers selected by the user and
        to generate the charts and result CSV files by classifier and
        for all combined.
        """

        if not (os.path.isdir("experiments/")):
            os.mkdir("experiments/")

        # Create the experiment dir
        if not (os.path.isdir(self.experiment_dir)):
            os.mkdir(self.experiment_dir)

        # Create a file to save the experiment info
        with open(self.experiment_dir + "/resume.txt", "wb") as resume_file:
          resume_file.write(self.resume())

        # The file with all the summary data resulted from classifiers trainning
        csvWriter = WekaClassifiersSummaryCSVWriter(self.specificities_points)

        # This is the ROC Builder used to build chart with all the curves
        # generated with cross validation during the trainning of the classifiers
        all_cv_roc_builder = WekaROCChartBuilder(title = "CV ROC for all classifiers")

        # This is the ROC Builder used to build the chart with all the curves
        # generated using the test dataset during classifier evaluation
        all_test_roc_builder = WekaROCChartBuilder(title = "Test ROC for all classifiers")

        if not (os.path.isdir(self.experiment_dir + "/model_data/")):
            # Some weka classifiers require the save the trainning model data in some folder
            os.mkdir(self.experiment_dir + "/model_data/")

        # For each classifier selected by the user executed the build and test
        # with the specified test dataset, print the result in CSV format and generate
        # individual graph for each classifier
        for classifier in self.classifiers:

            # Classifier directory inside experiment_dir. i.e /experiments/naive-bayes
            classifier_dir = self.experiment_dir + "/" + classifier['token']

            # The builder not create the classifier dir inside experiment dir
            # So create it before create the classifier
            if not (os.path.isdir(classifier_dir)):
                os.mkdir(classifier_dir)

            # Start to create the classifier with the dataset
            builder = WekaClassifierBuilder(experiment_dir = self.experiment_dir, classifier = classifier)

            command = builder.train_command(
                weka_lib = self.weka_jar,
                train_file = self.train_file)

            train_execution = builder.execute(command)

            # Add execution result to the chart of all classifiers cross validation
            all_cv_roc_builder.add_classifier(train_execution, classifier['name'])

            tester = WekaClassifierTester(experiment_dir = self.experiment_dir, classifier = classifier)

            summary_command, per_instance_command = tester.test_command(
                weka_lib = self.weka_jar,
                test_file = self.test_file)

            test_execution = tester.execute(summary_command, per_instance_command)

            # Add execution result to the chart of all classifiers test dataset ROC
            all_test_roc_builder.add_classifier(test_execution, classifier['name'])

            fullExecution = WekaClassifierFullExecution(train_execution, test_execution)

            # Write to the sumary CSV file the train and test results. ie. AROC and Specificities
            csvWriter.add_classifier(fullExecution)

            # Creates a chart for cross validation and test dataset ROC
            roc_builder = WekaROCChartBuilder(title = "CV and Test ROC for " + classifier['name'])
            roc_builder.add_classifier(test_execution, 'Test Dataset')
            roc_builder.add_classifier(train_execution, 'Cross Validation')
            roc_builder.write_to_file(file_location = classifier_dir + "/roc.pdf")

        # After all classifiers trainning, write the ROC charts for cross validation to a PDF
        all_test_roc_builder.write_to_file(file_location = self.experiment_dir + "/test_roc.pdf")

        # After all classifiers trainning, write the ROC charts for test dataset to a PDF
        all_cv_roc_builder.write_to_file(file_location = self.experiment_dir + "/train_roc.pdf")

        # Write the classifier result to a CSV file.
        csvWriter.write_to_file(self.experiment_dir + "/summary.csv")

    def resume(self):
        output = StringIO.StringIO()
        output.write("\n----------------------------------------------------")
        output.write("\nExperiment Name: %s" % self.experiment_dir)
        output.write("\nExperiment Date: %s" % self.experiment_date)
        output.write("\nWeka JAR file: %s " % self.weka_jar)
        output.write("\nTrainning dataset file: %s %s" % (self.train_file, self.train_md5))
        output.write("\nTesting dataset file: %s %s" % (self.test_file, self.test_md5))
        output.write("\nClassifiers: %s" % [c['name'] for c in self.classifiers])
        output.write("\nSpecificity points: %s" % self.specificities_points)
        output.write("\nInterpolation Kind: %s" % self.interpolation_kind)
        return output.getvalue()

def usage():
  print "\nThis is the usage function\n"
  print 'Usage: '+sys.argv[0]+' -e <experiment> --weka-dir=<weka_dir> [option]'

def main(argv):

    # Read all the parameters from command line
    try:
      opts, args = getopt.getopt(argv,"h:e:t:T:w:c:s:i:", ["experiment=","train=", "test=", "weka-jar=", "classifiers=", "specificity-points", "interpolation-kind="])
    except getopt.GetoptError as err:
      # will print something like "option -a not recognized"
      print str(err)
      usage()
      sys.exit(2)

    experiment = None
    train = None
    test = None
    weka_jar = None
    classifiers_list = list()
    interpolation_kind = 'linear'

    specificities_points = config.specificities_points

    # Read parameter by parameter from opts
    for opt, arg in opts:
        if opt == '-h':
            print 'glaucoma.py -e <experiment> -t <train_file> -w <weka_jar>'
            sys.exit()
        elif opt in ("-e", "--experiment"):
            experiment = arg
        elif opt in ("-t", "--train"):
            train = arg
        elif opt in ("-T", "--test"):
            test = arg
        elif opt in ("-w", "--weka-jar"):
            weka_jar = arg
        elif opt in ("-c", "--classifiers"):
            classifiers_list = [s.strip() for s in arg.split(',')]
        elif opt in ("-s", "--specificity-points"):
            points = [float(s.strip()) for s in arg.split(',')]
            if points:
                specificities_points = points
        elif opt in ("-i", "--interpolation-kind"):
            interpolation_kind = arg if arg in ['linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic' ] else config.interpolation_kind

    executor = WekaClassifierExecutor(
        experiment_dir = experiment,
        weka_jar = weka_jar,
        train_file = train,
        test_file = test,
        classifiers = classifiers_list,
        specificities_points = specificities_points,
        interpolation_kind = interpolation_kind,
        config = config)

    print(executor.resume())

    executor.run()

if __name__ == "__main__":
   main(sys.argv[1:])
